keys = require("app/common/keys.tui")

standardColor = vec4(1.0,1.0,1.0,1.0)
disabledColor = vec4(0.5,0.5,0.5,0.5)
selectedColor = vec4(0.5,0.5,1.0,1.0)

resize = function(textEntryView, size)
{
    userData = textEntryView.textEntryViewData
    textEntryView.size = size
    backgroundView = userData.backgroundView
    backgroundView.size = size
}

updateVisuals = function(userData)
{
    textEntryView = userData.view
    if(userData.textView)
    {
        if(userData.textView.text != userData.text)
        {
            if(userData.text)
            {
                userData.textView.text = userData.text
            }
            else
            {
                userData.textView.text = ""
            }

            userData.desiredBackgroundSize = userData.textView.size.x + 12
        }

        desiredBackgroundSize = userData.desiredBackgroundSize
        if(!desiredBackgroundSize)
        {
            desiredBackgroundSize = 0
        }
        if(userData.promptTextView)
        {
            desiredBackgroundSize = desiredBackgroundSize + userData.promptTextView.size.x
        }

        if(desiredBackgroundSize > userData.backgroundView.size.x)
        {
            newSize = vec2(desiredBackgroundSize, userData.backgroundView.size.y)
            resize(textEntryView, newSize)
        }
        elseif(desiredBackgroundSize < userData.backgroundView.size.x)
        {
            newWidth = math.max(desiredBackgroundSize, userData.minWidth)
            newSize = vec2(newWidth, userData.backgroundView.size.y)
            resize(textEntryView, newSize)
        }

        

        if(userData.disabled)
        {
            userData.textView.color = disabledColor
        }
        else
        {
            if(userData.selected or userData.editing)
            {
                userData.textView.color = selectedColor
            }
            else
            {
                userData.textView.color = standardColor
            }
        }
    }
}

#uiTextEntry.types = mj:enum {
#    "standard_10x3",
#    "wide",
#    "multiLine",
#    "chatInput",
#}

updateCursorPosition = function(userData)
{
    rect = userData.textView.getRectForCharAtIndex(-1 + userData.cursorOffset)
    xOffset = rect.x + rect.z
    if(!userData.horizontalAlignment or userData.horizontalAlignment == "center")
    {
        xOffset /= 2
    }
    #todo handle right alignment
    userData.cursorView.pos = vec3(xOffset + 1,rect.y + 1,0)
}

updateText = function(userData, newText)
{
    setText(userData, newText)

    if(userData.editing)
    {
        userData.cursorView.hidden = false
        userData.cursorTimer = 0.0

        updateCursorPosition(userData)
    }
    
    if(userData.textEntryChangedContinuousFunction)
    {
        userData.textEntryChangedContinuousFunction(userData.text)
    }
}

finishEditing = function(userData, confirmChanges)
{
    if(userData.editing)
    {
        userData.view.keyChanged = nil
        userData.editing = false
        userData.backgroundView.update = nil
        userData.cursorView.hidden = true
        updateVisuals(userData)
        eventManager.removeTextEntryListener(userData.textEntryListenerID)
        userData.textEntryListenerID = nil

        if((!userData.text) or string.length(userData.text) == 0)
        {
            if(userData.allowsEmpty)
            {
                userData.textEntryFinishedFunction("")
            }
            else
            {
                updateText(userData, userData.editStartTextValue)
            }
        }
        else
        {
            if(userData.textEntryFinishedFunction)
            {
                userData.textEntryFinishedFunction(userData.text, confirmChanges)
            }

            if(!confirmChanges)
            {
                updateText(userData, userData.editStartTextValue)
            }
        }
    }
}

showCursorAndResetTimerIfEditingForCursorChanged = function(userData)
{
    if(userData.editing)
    {
        userData.cursorView.hidden = false
        userData.cursorTimer = 0.0
        updateCursorPosition(userData)
    }
}

cursorChanged = function(userData, horizontalOffset, verticalOffset)
{
    if(userData.text)
    {
        textLength = string.length(userData.text)
        if(textLength > 0)
        {
            if(horizontalOffset)
            {
                userData.cursorOffset = userData.cursorOffset + horizontalOffset
                userData.textView.resetVerticalCursorMovementAnchors()
            }
            elseif(verticalOffset)
            {
                userData.cursorOffset = userData.textView.getCursorOffsetForVerticalCursorMovement(userData.cursorOffset, verticalOffset)
            }
            userData.cursorOffset = math.clamp(userData.cursorOffset, -textLength, 0)
            showCursorAndResetTimerIfEditingForCursorChanged(userData)
        }
    }
}

create = function(parentView, sizeOrNilForParentSize, typeOrNilFor10x3, horizontalAlignmentOrNilForCentered, descriptionTextOrNil)
{
    horizontalAlignment = horizontalAlignmentOrNilForCentered
    size = sizeOrNilForParentSize
    if(!sizeOrNilForParentSize)
    {
        size = parentView.size
    }
    
    userData = {
        horizontalAlignment = horizontalAlignment
        fontSize = 16
        font = "roboto" //todo
        cursorTimer = 0.0
        cursorOffset = 0
        minWidth = size.x
        descriptionText = descriptionTextOrNil
    }

    textEntryViewLayout = {
        type = "view"
    }

    textEntryView = parentView.addView(textEntryViewLayout)
    userData.view = textEntryView
    textEntryView.textEntryViewData = userData

    backgroundColor = vec4(0.0,0.0,0.0,0.8)
    verticalAlignment = MJPositionCenter


    yOffset = 0
    xOffset = 0
    
    if(verticalAlignment == "top")
    {
        yOffset = -7
    }
    if(userData.textOffset)
    {
        yOffset = yOffset + userData.textOffset
    }
    if(horizontalAlignment == "innerLeft")
    {
        xOffset = 4
    }

    userData.verticalAlignment = verticalAlignment

    backgroundViewLayout = {
        type = "color"
        color = backgroundColor
    }

    backgroundView = textEntryView.addView(backgroundViewLayout)
    userData.backgroundView = backgroundView


    cursorViewLayout = {
        size = vec2(1,18)
        type = "color"
        color = vec4(1.0,1.0,1.0,1.0)
        horizontalAlignment = "left"
        verticalAlignment = verticalAlignment
        pos = vec3(2,1,0)
    }
    
    cursorView = textEntryView.addView(cursorViewLayout)
    cursorView.hidden = true
    userData.cursorView = cursorView


    textViewLayout = {
        type = "text"
        font = userData.font
        fontSize = userData.fontSize
        horizontalAlignment = horizontalAlignment
        verticalAlignment = verticalAlignment
        pos = vec3(xOffset,yOffset,0)
    }

    textView = textEntryView.addView(textViewLayout)
    userData.initialOffset = textViewLayout.pos
    userData.textView = textView

    userData.cursorView.relativeView = textView

    updateCursorFunction = function(dt)
    {
        userData.cursorTimer = userData.cursorTimer + dt
        if(userData.cursorTimer > 0.5)
        {
            userData.cursorTimer = userData.cursorTimer - 0.5
            if(userData.cursorTimer > 0.5)
            {
                userData.cursorTimer = 0.0
            }
            cursorView.hidden = (!cursorView.hidden)
        }
    }
    #backgroundView.update = updateCursorFunction

    backgroundView.hoverStart = function()
    {
        if(!userData.selected)
        {
            if(!userData.disabled)
            {
                userData.selected = true
                #audio:playUISound(uiCommon.hoverSoundFile)
                updateVisuals(userData)
            }
        }
    }

    backgroundView.hoverEnd = function()
    {
        if(userData.selected)
        {
            userData.selected = false
            userData.mouseDown = false
            updateVisuals(userData)
        }
    }

    backgroundView.mouseDown = function (buttonIndex)
    {
        if(buttonIndex == 0)
        {
            if(!userData.mouseDown)
            {
                if(!userData.disabled)
                {
                    userData.mouseDown = true
                    updateVisuals(userData)
                    #audio:playUISound(uiCommon.clickDownSoundFile)
                }
            }
        }
    }

    backgroundView.mouseUp = function (buttonIndex)
    {
        if(buttonIndex == 0)
        {
            if(userData.mouseDown)
            {
                userData.mouseDown = false
                updateVisuals(userData)
                #audio:playUISound(uiCommon.clickReleaseSoundFile)
            }
        }
    }

    textViewClickFunction = function(mouseLoc)
    {
        if(!userData.disabled)
        {
            if(userData.clickFunction)
            {
                userData.clickFunction()
            }
            if(userData.editing)
            {
                error("todo")
                /*if(userData.text)
                {
                    textViewLoc = textEntryView:locationRelativeToView(mouseLoc, userData.textView)

                    charIndex = userData.textView:getCharIndexForPos(textViewLoc)
                    textLength = string.length(userData.text)
                    if(textLength > 0)
                    {
                        charIndex = mjm.clamp(charIndex, 0, textLength)
                        userData.cursorOffset = charIndex - textLength
                        userData.cursorView.hidden = false
                        userData.cursorTimer = 0.0
                        updateCursorPosition(userData)
                        textEntryView.textEntryViewData.textView.resetVerticalCursorMovementAnchors()
                    }
                }*/
                #mj:log("mouseLoc:", mouseLoc - vec2(textView.pos.x, textView.pos.y), " charIndex:", charIndex)
            }
            else
            {
                userData.editing = true
                #textEntryView.textEntryViewData.textView:resetVerticalCursorMovementAnchors()
                userData.editStartTextValue = userData.text
                cursorView.hidden = false
                userData.cursorTimer = 0.0
                userData.cursorOffset = 0
                backgroundView.update = updateCursorFunction
                updateVisuals(userData)
                updateCursorPosition(userData)
                
                keyMap = {
                    [keys.keyCodes.key_return] = function(isDown, keyCode, modCode, isRepeat)
                    {
                        if(isDown and (!isRepeat))
                        {
                            #print("modCode:", modCode)
                            finishEditing(userData, true)
                        }
                    }
                    [keys.keyCodes.backspace] = function(isDown, keyCode, modCode, isRepeat)
                    {
                        if(isDown)
                        {
                            if(userData.text and string.length(userData.text) > 0)
                            {
                                newText = ""
                                if(userData.cursorOffset and userData.cursorOffset != 0)
                                {
                                    textLength = string.length(userData.text)
                                    if(textLength > 0)
                                    {
                                        removePos = math.max(textLength + userData.cursorOffset, 0)
                                        if(removePos > 0)
                                        {
                                            newText = string.subString(userData.text,0,removePos) + string.subString(userData.text, removePos + 1)
                                        }
                                        else
                                        {
                                            return 
                                        }
                                    }
                                    else
                                    {
                                        return
                                    }
                                }
                                else
                                {
                                    newText = string.subString(userData.text, 0, string.length(userData.text) - 1)
                                }
                                updateText(userData, newText)
                            }
                        }
                        return true
                    }
                    [keys.keyCodes.escape] = function(isDown, keyCode, modCode, isRepeat)
                    {
                        if(isDown and (!isRepeat))
                        {
                            finishEditing(userData, false)
                        }
                    }
                    [keys.keyCodes.left] = function(isDown, keyCode, modCode, isRepeat)
                    {
                        if(isDown)
                        {
                            cursorChanged(userData, -1, nil)
                        }
                    }
                    [keys.keyCodes.right] = function(isDown, keyCode, modCode, isRepeat)
                    {
                        if(isDown)
                        {
                            cursorChanged(userData, 1, nil)
                        }
                    }
                    #[keyMapping:getMappingIndex("textEntry", "newline")] = function(isDown, isRepeat)
                    #    if(isDown)
                    #    {
                    #        newText = userData.text .. "\n"
                    #        updateText(userData, newText)
                    #    }
                    #    return true 
                    #end,
                    /*[
                    [keyMapping:getMappingIndex("textEntry", "delete")] = function(isDown, isRepeat)
                        if(isDown)
                            {
                            if(userData.text and string.length(userData.text) > 0)
                            {
                                newText = ""
                                if(userData.cursorOffset and userData.cursorOffset ~= 0)
                                {
                                    textLength = string.length(userData.text)
                                    if(textLength > 0)
                                    {
                                        removeAfterPos = math.max(textLength + userData.cursorOffset, 0) + 1
                                        if(removeAfterPos > 0 and removeAfterPos < textLength)
                                        {
                                            newText = userData.text:sub(1,removeAfterPos - 1) .. userData.text:sub(removeAfterPos + 1,-1)
                                            userData.cursorOffset = userData.cursorOffset + 1
                                        }
                                        else
                                        {
                                            return 
                                        }
                                    }
                                    else
                                    {
                                        return
                                    }
                                }
                                else
                                {
                                    newText = userData.text:sub(1, -2)
                                }

                                updateText(userData, newText)
                            }
                        }
                        return true
                    end,
                    [keyMapping:getMappingIndex("game", "escape")] = function(isDown, isRepeat)
                        if(isDown and (!isRepeat))
                        {
                            finishEditing(userData, false)
                        }
                        return true 
                    end,
                   [keyMapping:getMappingIndex("textEntry", "prevCommand")] = function(isDown, isRepeat) if(isDown then cursorChanged(userData, nil, 1) end return true end,
                    [keyMapping:getMappingIndex("textEntry", "nextCommand")] = function(isDown, isRepeat) if(isDown then cursorChanged(userData, nil, -1) end return true end,
                    */
                }

                keyChanged = function(isDown, keyCode, modCode, isRepeat)
                {
                    func = keyMap[keyCode]
                    if(func)
                    {
                        func(isDown, keyCode, modCode, isRepeat)
                    }
                }

                stringInsert = function(str1, str2, pos)
                {
                    #return str1:sub(1,pos)..str2..str1:sub(pos+1)
                    return string.subString(str1, 0, pos) + str2 + string.subString(str1, pos)
                }

                textEntry = function(text)
                {
                    newText = text
                    if(userData.text)
                    {
                        if(userData.cursorOffset < 0)
                        {
                            textLength = string.length(userData.text)
                            if(textLength > 0)
                            {
                                insertAfterPos = math.max(textLength + userData.cursorOffset, 0)
                                newText = stringInsert(userData.text, text, insertAfterPos)
                            }
                        }
                        else
                        {
                            newText = userData.text + text
                        }
                    }
                    updateText(userData, newText)
                }
                
                userData.textEntryListenerID = eventManager.setTextEntryListener(textEntry, keyChanged)
            }
        }
    }

    userData.textViewClickFunction = textViewClickFunction
    backgroundView.click = textViewClickFunction
    
    backgroundView.clickDownOutside = function()
    {
        finishEditing(userData, false)
    }

    #

    #textEntryView.update = uiCommon:createButtonUpdateFunction(userData, textEntryView)


    return textEntryView
}

setOnChangeCallback = function(textEntryView, callbackFunc)
{
    textEntryView.textEntryViewData.textEntryFinishedFunction = callbackFunc
}

setAllowsEmpty = function(textEntryView, allowsEmpty)
{ #defaults to not allowing empty strings
    textEntryView.textEntryViewData.allowsEmpty = allowsEmpty
}

setChangedContinuousCallback = function(textEntryView, callbackFunc)
{
    textEntryView.textEntryViewData.textEntryChangedContinuousFunction = callbackFunc
}

setSelected = function(textEntryView, selected)
{
    if(selected != textEntryView.textEntryViewData.selected)
    {
        textEntryView.textEntryViewData.selected = selected
        updateVisuals(textEntryView.textEntryViewData)
    }
}

setDisabled = function(textEntryView, disabled)
{
    if(disabled != textEntryView.textEntryViewData.disabled)
    {
        textEntryView.textEntryViewData.disabled = disabled
        updateVisuals(textEntryView.textEntryViewData)
    }
}

isEditing = function(textEntryView)
{
    return textEntryView.textEntryViewData.editing
}

callClickFunction = function(textEntryView)
{
    textEntryView.textEntryViewData.textViewClickFunction()
}

setText = function(userData, text_)
{
    textToUse = text_
    if(!textToUse)
    {
        textToUse = ""
    }
    elseif(type(textToUse) != "string")
    {
        #textToUse = mj:tostring(textToUse) todo
    }

    if(userData.maxChars and textToUse and string.length(textToUse) > userData.maxChars)
    {
        textToUse = string.subString(textToUse, 0, userData.maxChars)
    }
    userData.text = textToUse
    if(!userData.editing)
    {
        userData.cursorOffset = 0
    }
    else
    {
        if(textToUse)
        {
            if(userData.cursorOffset < -string.length(textToUse))
            {
                userData.cursorOffset = -string.length(textToUse)
            }
        }
        else
        {
            userData.cursorOffset = 0
        }
    }
    
    updateVisuals(userData)
    #userData.textView:resetVerticalCursorMovementAnchors() #todo
    showCursorAndResetTimerIfEditingForCursorChanged(userData)
}

clearText = function(userData)
{
    setText(userData, "")
}

setMaxChars = function(textEntryView, maxChars)
{
    textEntryView.textEntryViewData.maxChars = maxChars
}

getText = function(textEntryView)
{
    return textEntryView.textEntryViewData.text
}

setPromptText = function(textEntryView, promptText, promptColor)
{
    userData = textEntryView.textEntryViewData
    if(textEntryView.textEntryViewData.promptTextView)
    {
        textEntryView.removeView(textEntryView.textEntryViewData.promptTextView)
    }

    if(promptText and promptText != "")
    {
        /*promptTextView = TextView.new(textEntryView) #todo
        promptTextView.font = Font(userData.fontName, userData.fontSize)
        promptTextView.relativePosition = ViewPosition(userData.horizontalAlignment, userData.verticalAlignment)
        promptTextView.pos = userData.initialOffset

        promptTextView:addColoredText(promptText, promptColor)
    
        textEntryView.textEntryViewData.promptTextView = promptTextView

        userData.textView.pos = userData.initialOffset + vec3(promptTextView.size.x,0,0) #todo this only supports left alignment
        */
    }
}